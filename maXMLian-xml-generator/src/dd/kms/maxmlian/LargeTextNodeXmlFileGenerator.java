package dd.kms.maxmlian;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.util.Locale;
import java.util.Random;
import java.util.function.IntToDoubleFunction;

public class LargeTextNodeXmlFileGenerator extends AbstractXmlFileGenerator
{
	private static final NumberFormat	NUMBER_FORMAT				= new DecimalFormat("#0.00000", new DecimalFormatSymbols(Locale.US));

	/**
	 * Estimate for the average number of characters when formatting the numbers
	 * with {@link #NUMBER_FORMAT}. The exact value depends on the actual numbers
	 * and is hard to predict.
	 */
	private static final int			NUM_CHARACTERS_PER_NUMBER	= 10;
	private static final int			MAX_LINE_SIZE				= 1024;

	private final long		targetFileSize;
	private final Random	random	= new Random(123456789L);

	public LargeTextNodeXmlFileGenerator(long targetFileSize) {
		this.targetFileSize = targetFileSize;
	}

	public synchronized void generate(Path file) throws IOException {
		try (BufferedWriter writer = Files.newBufferedWriter(file, StandardCharsets.UTF_8)) {
			reset(writer);
			write("<?xml version=\"1.0\"?>");
			write("<!-- autogenerated by class LargeTextNodeXmlFileGenerator -->");
			writeMeasurement();
		}
	}

	private void writeMeasurement() throws IOException {
		try (Element measurement = new Element("Measurement")) {
			writeSignal();
		}
	}

	private void writeSignal() throws IOException {
		double dNumValues = (long) Math.ceil(targetFileSize / (2.0 * (NUM_CHARACTERS_PER_NUMBER + 1)));
		int numValues = (int) (Math.min(dNumValues, Integer.MAX_VALUE));

		try (Element signal = new Element("Signal")) {
			writeX(numValues);
			writeY(numValues);
		}
	}

	private void writeX(int numValues) throws IOException {
		double delta = 0.1;

		// generates approximately 0*delta, 1*delta, 2*delta, ...)
		IntToDoubleFunction xValues = i -> delta * (i + 0.1 * (random.nextDouble() - 0.5));

		writeValues("X", xValues, numValues);
	}

	private void writeY(int numValues) throws IOException {
		double delta = 10;

		// generates a random walk starting at 0 with step size uniformly chosen from [-delta/2, delta/2)
		IntToDoubleFunction yValues = new IntToDoubleFunction() {
			private double lastValue = 0;

			@Override
			public double applyAsDouble(int value) {
				lastValue = lastValue + delta * ((random.nextDouble() - 0.5));
				return lastValue;
			}
		};

		writeValues("Y", yValues, numValues);
	}

	private void writeValues(String valuesName, IntToDoubleFunction values, int numValues) throws IOException {
		try (Element valuesElement = new Element(valuesName)) {
			StringBuilder lineBuilder = new StringBuilder();
			for (int i = 0; i < numValues; i++) {
				double value = values.applyAsDouble(i);
				String formattedValue = NUMBER_FORMAT.format(value);
				if (lineBuilder.length() > 0 && lineBuilder.length() + formattedValue.length() + 1 > MAX_LINE_SIZE) {
					write(lineBuilder.toString());
					lineBuilder.setLength(0);
				}
				lineBuilder.append(formattedValue);
				if (i + 1 < numValues) {
					lineBuilder.append(';');
				}
			}
			write(lineBuilder.toString());
			lineBuilder.setLength(0);
		}
	}
}
